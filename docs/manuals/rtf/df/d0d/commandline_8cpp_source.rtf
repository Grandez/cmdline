{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
commandline.cpp\par \pard\plain 
{\tc\tcl2 \v commandline.cpp}
{\xe \v commandline.cpp}
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\bkmkstart AAAAAAACGG}{\bkmkend AAAAAAACGG}
00001 {\cf21 #define _CRT_SECURE_NO_WARNINGS}\par
{\bkmkstart AAAAAAACGH}{\bkmkend AAAAAAACGH}
00002 {\cf21 #include <iostream>}\par
{\bkmkstart AAAAAAACGI}{\bkmkend AAAAAAACGI}
00003 {\cf21 #include <vector>}\par
{\bkmkstart AAAAAAACGJ}{\bkmkend AAAAAAACGJ}
00004 \par
{\bkmkstart AAAAAAACGK}{\bkmkend AAAAAAACGK}
00005 {\cf21 #include "config.h"}\par
{\bkmkstart AAAAAAACGL}{\bkmkend AAAAAAACGL}
00006 {\cf21 #include "commandline.hpp"}\par
{\bkmkstart AAAAAAACGM}{\bkmkend AAAAAAACGM}
00007 {\cf21 #include "argument.hpp"}\par
{\bkmkstart AAAAAAACGN}{\bkmkend AAAAAAACGN}
00008 {\cf21 #include "tools.hpp"}\par
{\bkmkstart AAAAAAACGO}{\bkmkend AAAAAAACGO}
00009 {\cf21 #include "validations.hpp"}\par
{\bkmkstart AAAAAAACGP}{\bkmkend AAAAAAACGP}
00010 {\cf21 #include "cmdline_exceptions.hpp"}\par
{\bkmkstart AAAAAAACGQ}{\bkmkend AAAAAAACGQ}
00011 {\cf21 #include "defines.hpp"}\par
{\bkmkstart AAAAAAACGR}{\bkmkend AAAAAAACGR}
00012 \par
{\bkmkstart AAAAAAACGS}{\bkmkend AAAAAAACGS}
00013 {\cf21 #include "commandline_aux.hpp"}\par
{\bkmkstart AAAAAAACGT}{\bkmkend AAAAAAACGT}
00014 \par
{\bkmkstart AAAAAAACGU}{\bkmkend AAAAAAACGU}
00015 {\cf17 using namespace }std;\par
{\bkmkstart AAAAAAACGV}{\bkmkend AAAAAAACGV}
00016 \par
{\bkmkstart AAAAAAACGW}{\bkmkend AAAAAAACGW}
00017 {\cf17 namespace }{\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAM" }{}}{\fldrslt {\cs37\ul\cf2 _cmdline}}}
 \{\par
{\bkmkstart AAAAAAACGX}{\bkmkend AAAAAAACGX}
00018 {\cf17 constexpr} {\cf17 auto} OPTION_OR_DEFINITION = {\cf23 '/'};\par
{\bkmkstart AAAAAAACGY}{\bkmkend AAAAAAACGY}
00019 {\cf17 constexpr} {\cf17 auto}  FLAG_ACTIVE         =  {\cf23 '+'};\par
{\bkmkstart AAAAAAACGZ}{\bkmkend AAAAAAACGZ}
00020 {\cf17 constexpr} {\cf17 auto}  FLAG_INACTIVE       =  {\cf23 '-'};\par
{\bkmkstart AAAAAAACHA}{\bkmkend AAAAAAACHA}
00021 \par
{\bkmkstart AAAAAAACHB}{\bkmkend AAAAAAACHB}
00022     ParameterTree* rootOptions[128];\par
{\bkmkstart AAAAAAACHC}{\bkmkend AAAAAAACHC}
00023     ParameterTree* rootFlags[128];\par
{\bkmkstart AAAAAAACHD}{\bkmkend AAAAAAACHD}
00024     {\cf18 char} *programName = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACHE}{\bkmkend AAAAAAACHE}
00025     {\cf18 void} launchHelpIfActive(CommandLine *ptr) \{\par
{\bkmkstart AAAAAAACHF}{\bkmkend AAAAAAACHF}
00026         {\cf18 int} help = 0;\par
{\bkmkstart AAAAAAACHG}{\bkmkend AAAAAAACHG}
00027         HelpRequested *ex = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACHH}{\bkmkend AAAAAAACHH}
00028         {\cf19 if} (ptr->hasFlag({\cf22 "HELP"})) help |= 2;\par
{\bkmkstart AAAAAAACHI}{\bkmkend AAAAAAACHI}
00029         {\cf19 if} (ptr->hasFlag({\cf22 "help"})) help |= 1;\par
{\bkmkstart AAAAAAACHJ}{\bkmkend AAAAAAACHJ}
00030         {\cf19 if} (help) \{\par
{\bkmkstart AAAAAAACHK}{\bkmkend AAAAAAACHK}
00031             Flags flags = ptr->getDefaultFlags({\cf17 false});\par
{\bkmkstart AAAAAAACHL}{\bkmkend AAAAAAACHL}
00032             std::unordered_map<string, string> options = ptr->getDefaultOptions();\par
{\bkmkstart AAAAAAACHM}{\bkmkend AAAAAAACHM}
00033             {\cf17 delete} ptr;\par
{\bkmkstart AAAAAAACHN}{\bkmkend AAAAAAACHN}
00034             {\cf19 if} (help >= 2) {\cf19 throw} {\cf17 new} HelpDetailedRequested(strdup(programName), flags, options);\par
{\bkmkstart AAAAAAACHO}{\bkmkend AAAAAAACHO}
00035             {\cf19 throw} {\cf17 new} HelpSimpleRequested(strdup(programName), flags, options);\par
{\bkmkstart AAAAAAACHP}{\bkmkend AAAAAAACHP}
00036         \}\par
{\bkmkstart AAAAAAACHQ}{\bkmkend AAAAAAACHQ}
00037     \}\par
{\bkmkstart AAAAAAACHR}{\bkmkend AAAAAAACHR}
00038                         CommandLine::CommandLine({\cf18 int} argc, {\cf17 const} {\cf18 char}** argv, Parameters parms, {\cf18 bool} sensitive, {\cf18 bool} strict) \{\par
{\bkmkstart AAAAAAACHS}{\bkmkend AAAAAAACHS}
00039         std::cout << {\cf22 "Crea CommandLine\\n"};\par
{\bkmkstart AAAAAAACHT}{\bkmkend AAAAAAACHT}
00040         this->sensitive = sensitive;\par
{\bkmkstart AAAAAAACHU}{\bkmkend AAAAAAACHU}
00041         this->strict = strict;\par
{\bkmkstart AAAAAAACHV}{\bkmkend AAAAAAACHV}
00042         memset(&rootOptions, 0x0, {\cf17 sizeof}(rootOptions));\par
{\bkmkstart AAAAAAACHW}{\bkmkend AAAAAAACHW}
00043         memset(&rootFlags, 0x0, {\cf17 sizeof}(rootFlags));\par
{\bkmkstart AAAAAAACHX}{\bkmkend AAAAAAACHX}
00044         loadParameters(parms);\par
{\bkmkstart AAAAAAACHY}{\bkmkend AAAAAAACHY}
00045         updateValuesFromEnvironment();\par
{\bkmkstart AAAAAAACHZ}{\bkmkend AAAAAAACHZ}
00046         loadHelpFlags();\par
{\bkmkstart AAAAAAACIA}{\bkmkend AAAAAAACIA}
00047         parseCommandLine(argc, argv);\par
{\bkmkstart AAAAAAACIB}{\bkmkend AAAAAAACIB}
00048     \}\par
{\bkmkstart AAAAAAACIC}{\bkmkend AAAAAAACIC}
00049                         CommandLine::~CommandLine() \{\par
{\bkmkstart AAAAAAACID}{\bkmkend AAAAAAACID}
00050         std::cout << {\cf22 "Delete CommandLine\\n"};\par
{\bkmkstart AAAAAAACIE}{\bkmkend AAAAAAACIE}
00051         {\cf19 for} ({\cf18 int} i = 0; i < 128; i++) \{\par
{\bkmkstart AAAAAAACIF}{\bkmkend AAAAAAACIF}
00052             \par
{\bkmkstart AAAAAAACIG}{\bkmkend AAAAAAACIG}
00053             {\cf19 if} (rootOptions[i]) \{\par
{\bkmkstart AAAAAAACIH}{\bkmkend AAAAAAACIH}
00054                 std::cout << {\cf22 "deleting option "} << i << {\cf22 "\\n"};\par
{\bkmkstart AAAAAAACII}{\bkmkend AAAAAAACII}
00055                 {\cf17 delete} rootOptions[i];\par
{\bkmkstart AAAAAAACIJ}{\bkmkend AAAAAAACIJ}
00056             \}\par
{\bkmkstart AAAAAAACIK}{\bkmkend AAAAAAACIK}
00057             {\cf19 if} (rootFlags[i])  \{\par
{\bkmkstart AAAAAAACIL}{\bkmkend AAAAAAACIL}
00058                 std::cout << {\cf22 "deleting flag "} << i << {\cf22 "\\n"};\par
{\bkmkstart AAAAAAACIM}{\bkmkend AAAAAAACIM}
00059                 {\cf17 delete} rootFlags[i];\par
{\bkmkstart AAAAAAACIN}{\bkmkend AAAAAAACIN}
00060             \}\par
{\bkmkstart AAAAAAACIO}{\bkmkend AAAAAAACIO}
00061         \}\par
{\bkmkstart AAAAAAACIP}{\bkmkend AAAAAAACIP}
00062         std::cout << {\cf22 "Fin Delete CommandLine\\n"};\par
{\bkmkstart AAAAAAACIQ}{\bkmkend AAAAAAACIQ}
00063     \}\par
{\bkmkstart AAAAAAACIR}{\bkmkend AAAAAAACIR}
00064     vector<const char*> CommandLine::getArgs() \{\par
{\bkmkstart AAAAAAACIS}{\bkmkend AAAAAAACIS}
00065         {\cf19 return} inputs;\par
{\bkmkstart AAAAAAACIT}{\bkmkend AAAAAAACIT}
00066     \}\par
{\bkmkstart AAAAAAACIU}{\bkmkend AAAAAAACIU}
00067     {\cf18 bool}   CommandLine::hasFlag({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACIV}{\bkmkend AAAAAAACIV}
00068         Argument& opt = find(&flags, name);\par
{\bkmkstart AAAAAAACIW}{\bkmkend AAAAAAACIW}
00069         {\cf19 return} makeBoolean(opt.getValue());\par
{\bkmkstart AAAAAAACIX}{\bkmkend AAAAAAACIX}
00070     \}\par
{\bkmkstart AAAAAAACIY}{\bkmkend AAAAAAACIY}
00071     Flags  CommandLine::getDefaultFlags({\cf18 bool} allValues) \{ {\cf20 // Valores por defecto}\par
{\bkmkstart AAAAAAACIZ}{\bkmkend AAAAAAACIZ}
00072         {\cf19 return} getFlags(allValues, {\cf17 true});\par
{\bkmkstart AAAAAAACJA}{\bkmkend AAAAAAACJA}
00073     \}\par
{\bkmkstart AAAAAAACJB}{\bkmkend AAAAAAACJB}
00074     Flags  CommandLine::getCurrentFlags({\cf18 bool} allValues) \{\par
{\bkmkstart AAAAAAACJC}{\bkmkend AAAAAAACJC}
00075         {\cf19 return} getFlags(allValues, {\cf17 false});\par
{\bkmkstart AAAAAAACJD}{\bkmkend AAAAAAACJD}
00076     \}\par
{\bkmkstart AAAAAAACJE}{\bkmkend AAAAAAACJE}
00077     {\cf18 bool}   CommandLine::hasOption({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACJF}{\bkmkend AAAAAAACJF}
00078         Argument& opt = find(&options, name);\par
{\bkmkstart AAAAAAACJG}{\bkmkend AAAAAAACJG}
00079         {\cf19 return} (strlen(opt.getValue()) == 0 ? {\cf17 false} : {\cf17 true});\par
{\bkmkstart AAAAAAACJH}{\bkmkend AAAAAAACJH}
00080     \}\par
{\bkmkstart AAAAAAACJI}{\bkmkend AAAAAAACJI}
00081     {\cf18 bool}   CommandLine::isOptionMultiple({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACJJ}{\bkmkend AAAAAAACJJ}
00082         Argument& opt = find(&options, name);\par
{\bkmkstart AAAAAAACJK}{\bkmkend AAAAAAACJK}
00083         {\cf19 return} (opt.values.size() > 1);\par
{\bkmkstart AAAAAAACJL}{\bkmkend AAAAAAACJL}
00084     \}\par
{\bkmkstart AAAAAAACJM}{\bkmkend AAAAAAACJM}
00085     vector<const char*> CommandLine::getOptionValues({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACJN}{\bkmkend AAAAAAACJN}
00086         Argument& opt = find(&options, name);\par
{\bkmkstart AAAAAAACJO}{\bkmkend AAAAAAACJO}
00087         {\cf19 return} opt.getValues();\par
{\bkmkstart AAAAAAACJP}{\bkmkend AAAAAAACJP}
00088     \}\par
{\bkmkstart AAAAAAACJQ}{\bkmkend AAAAAAACJQ}
00089     {\cf18 int}    CommandLine::getOptionNumValues({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACJR}{\bkmkend AAAAAAACJR}
00090         Argument& opt = find(&options, name);\par
{\bkmkstart AAAAAAACJS}{\bkmkend AAAAAAACJS}
00091         {\cf19 return} ({\cf18 int}) opt.values.size();\par
{\bkmkstart AAAAAAACJT}{\bkmkend AAAAAAACJT}
00092     \}\par
{\bkmkstart AAAAAAACJU}{\bkmkend AAAAAAACJU}
00093     {\cf17 const} {\cf18 char}* CommandLine::getOption({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACJV}{\bkmkend AAAAAAACJV}
00094         {\cf19 return} getValue(&options, name);\par
{\bkmkstart AAAAAAACJW}{\bkmkend AAAAAAACJW}
00095     \}\par
{\bkmkstart AAAAAAACJX}{\bkmkend AAAAAAACJX}
00096     unordered_map<string,string>  CommandLine::getDefaultOptions() \{\par
{\bkmkstart AAAAAAACJY}{\bkmkend AAAAAAACJY}
00097         {\cf19 return} getOptionsValue({\cf17 true});\par
{\bkmkstart AAAAAAACJZ}{\bkmkend AAAAAAACJZ}
00098     \}\par
{\bkmkstart AAAAAAACKA}{\bkmkend AAAAAAACKA}
00099     Options CommandLine::getCurrentOptions() \{\par
{\bkmkstart AAAAAAACKB}{\bkmkend AAAAAAACKB}
00100 {\cf20 //      return getOptionsValues(false);}\par
{\bkmkstart AAAAAAACKC}{\bkmkend AAAAAAACKC}
00101         {\cf19 return} Options();\par
{\bkmkstart AAAAAAACKD}{\bkmkend AAAAAAACKD}
00102     \}\par
{\bkmkstart AAAAAAACKE}{\bkmkend AAAAAAACKE}
00103     {\cf18 bool}    CommandLine::hasDefinition({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACKF}{\bkmkend AAAAAAACKF}
00104         Argument* opt = findPointer(&defines, name);\par
{\bkmkstart AAAAAAACKG}{\bkmkend AAAAAAACKG}
00105         {\cf19 return} (opt == {\cf17 nullptr}) ? false : {\cf17 true};\par
{\bkmkstart AAAAAAACKH}{\bkmkend AAAAAAACKH}
00106     \}\par
{\bkmkstart AAAAAAACKI}{\bkmkend AAAAAAACKI}
00107     {\cf18 bool}    CommandLine::isDefinitionMultiple({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACKJ}{\bkmkend AAAAAAACKJ}
00108         Argument& opt = find(&defines, name);\par
{\bkmkstart AAAAAAACKK}{\bkmkend AAAAAAACKK}
00109         {\cf19 return} (opt.values.size() < 2 ? {\cf17 false} : {\cf17 true});\par
{\bkmkstart AAAAAAACKL}{\bkmkend AAAAAAACKL}
00110     \}\par
{\bkmkstart AAAAAAACKM}{\bkmkend AAAAAAACKM}
00111     vector<const char*>  CommandLine::getDefinitionValues({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACKN}{\bkmkend AAAAAAACKN}
00112         Argument& opt = find(&defines, name);\par
{\bkmkstart AAAAAAACKO}{\bkmkend AAAAAAACKO}
00113         {\cf19 return} opt.getValues();\par
{\bkmkstart AAAAAAACKP}{\bkmkend AAAAAAACKP}
00114     \}\par
{\bkmkstart AAAAAAACKQ}{\bkmkend AAAAAAACKQ}
00115     {\cf18 int}      CommandLine::getDefinitionNumValues({\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACKR}{\bkmkend AAAAAAACKR}
00116         Argument& opt = find(&defines, name);\par
{\bkmkstart AAAAAAACKS}{\bkmkend AAAAAAACKS}
00117         {\cf19 return} ({\cf18 int}) opt.values.size();\par
{\bkmkstart AAAAAAACKT}{\bkmkend AAAAAAACKT}
00118     \}\par
{\bkmkstart AAAAAAACKU}{\bkmkend AAAAAAACKU}
00119     Options  CommandLine::getDefinitions() \{\par
{\bkmkstart AAAAAAACKV}{\bkmkend AAAAAAACKV}
00120         Options opts;\par
{\bkmkstart AAAAAAACKW}{\bkmkend AAAAAAACKW}
00121         {\cf19 for} ({\cf17 auto} it = defines.begin(); it != defines.end(); it++)\{\par
{\bkmkstart AAAAAAACKX}{\bkmkend AAAAAAACKX}
00122             opts.emplace(it->second.name, it->second.getStringValues());\par
{\bkmkstart AAAAAAACKY}{\bkmkend AAAAAAACKY}
00123         \}\par
{\bkmkstart AAAAAAACKZ}{\bkmkend AAAAAAACKZ}
00124         {\cf19 return} opts;\par
{\bkmkstart AAAAAAACLA}{\bkmkend AAAAAAACLA}
00125     \}\par
{\bkmkstart AAAAAAACLB}{\bkmkend AAAAAAACLB}
00126     unordered_map<string, string> CommandLine::getOptionsValue({\cf18 bool} def) \{\par
{\bkmkstart AAAAAAACLC}{\bkmkend AAAAAAACLC}
00127         unordered_map<string, string> act;\par
{\bkmkstart AAAAAAACLD}{\bkmkend AAAAAAACLD}
00128         {\cf19 for} ({\cf17 auto} it : options) \{\par
{\bkmkstart AAAAAAACLE}{\bkmkend AAAAAAACLE}
00129             act.emplace(it.first, it.second.getValue());\par
{\bkmkstart AAAAAAACLF}{\bkmkend AAAAAAACLF}
00130 {\cf20 //          string str((def ? it.second.defValue : it.second.getValue()));}\par
{\bkmkstart AAAAAAACLG}{\bkmkend AAAAAAACLG}
00131 {\cf20 //          vector<string> v;}\par
{\bkmkstart AAAAAAACLH}{\bkmkend AAAAAAACLH}
00132 {\cf20 //          v.push_back(def ? it.second.defValue : it.second.getValue());}\par
{\bkmkstart AAAAAAACLI}{\bkmkend AAAAAAACLI}
00133 {\cf20 //          if (it.second.source != Source::AUTO) act.emplace(it.second.name, v);}\par
{\bkmkstart AAAAAAACLJ}{\bkmkend AAAAAAACLJ}
00134         \}\par
{\bkmkstart AAAAAAACLK}{\bkmkend AAAAAAACLK}
00135         {\cf19 return} act;\par
{\bkmkstart AAAAAAACLL}{\bkmkend AAAAAAACLL}
00136     \}\par
{\bkmkstart AAAAAAACLM}{\bkmkend AAAAAAACLM}
00137     {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAFA" }{}}{\fldrslt {\cs37\ul\cf2 cmdline::Type}}}
 CommandLine::getType({\cf17 const} {\cf18 char} *name) \{\par
{\bkmkstart AAAAAAACLN}{\bkmkend AAAAAAACLN}
00138         Argument* opt = options.find(name);\par
{\bkmkstart AAAAAAACLO}{\bkmkend AAAAAAACLO}
00139         {\cf19 return} opt->type;\par
{\bkmkstart AAAAAAACLP}{\bkmkend AAAAAAACLP}
00140     \}\par
{\bkmkstart AAAAAAACLQ}{\bkmkend AAAAAAACLQ}
00141     \par
{\bkmkstart AAAAAAACLR}{\bkmkend AAAAAAACLR}
00142     {\cf20 // /////////////////////////////////////////////////////////////}\par
{\bkmkstart AAAAAAACLS}{\bkmkend AAAAAAACLS}
00143     {\cf20 // PRIVATES}\par
{\bkmkstart AAAAAAACLT}{\bkmkend AAAAAAACLT}
00144     {\cf20 // /////////////////////////////////////////////////////////////}\par
{\bkmkstart AAAAAAACLU}{\bkmkend AAAAAAACLU}
00145     {\cf18 void}  CommandLine::parseCommandLine({\cf18 int} argc, {\cf17 const} {\cf18 char}** argv) \{\par
{\bkmkstart AAAAAAACLV}{\bkmkend AAAAAAACLV}
00146          programName = strdup(argv[0]);\par
{\bkmkstart AAAAAAACLW}{\bkmkend AAAAAAACLW}
00147          {\cf18 char} *configFile = configFileInCommandLine(argc, argv);\par
{\bkmkstart AAAAAAACLX}{\bkmkend AAAAAAACLX}
00148          {\cf19 if} (configFile) processConfigFile(configFile);\par
{\bkmkstart AAAAAAACLY}{\bkmkend AAAAAAACLY}
00149 \par
{\bkmkstart AAAAAAACLZ}{\bkmkend AAAAAAACLZ}
00150          {\cf18 char} firstLetter;\par
{\bkmkstart AAAAAAACMA}{\bkmkend AAAAAAACMA}
00151          {\cf18 char} parmName[64] = {\cf22 ""};\par
{\bkmkstart AAAAAAACMB}{\bkmkend AAAAAAACMB}
00152          {\cf18 char}* prevToken = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACMC}{\bkmkend AAAAAAACMC}
00153 \par
{\bkmkstart AAAAAAACMD}{\bkmkend AAAAAAACMD}
00154          {\cf19 for} ({\cf18 int} idxArgument = 1; idxArgument < argc; idxArgument++) \{\par
{\bkmkstart AAAAAAACME}{\bkmkend AAAAAAACME}
00155               firstLetter = getFirstCharacter(argv[idxArgument]);\par
{\bkmkstart AAAAAAACMF}{\bkmkend AAAAAAACMF}
00156               {\cf19 if} (isParameter(firstLetter)) \{\par
{\bkmkstart AAAAAAACMG}{\bkmkend AAAAAAACMG}
00157                   copyParameterInUpperCase(argv[idxArgument], sensitive, parmName);\par
{\bkmkstart AAAAAAACMH}{\bkmkend AAAAAAACMH}
00158                \}\par
{\bkmkstart AAAAAAACMI}{\bkmkend AAAAAAACMI}
00159                {\cf19 switch} (firstLetter) \{\par
{\bkmkstart AAAAAAACMJ}{\bkmkend AAAAAAACMJ}
00160                        {\cf19 case} OPTION_OR_DEFINITION: \par
{\bkmkstart AAAAAAACMK}{\bkmkend AAAAAAACMK}
00161                             {\cf19 if} (isConfigFile(argc, argv, idxArgument, sensitive)) \{\par
{\bkmkstart AAAAAAACML}{\bkmkend AAAAAAACML}
00162                                 idxArgument++;\par
{\bkmkstart AAAAAAACMM}{\bkmkend AAAAAAACMM}
00163                                 {\cf19 break};\par
{\bkmkstart AAAAAAACMN}{\bkmkend AAAAAAACMN}
00164                             \}\par
{\bkmkstart AAAAAAACMO}{\bkmkend AAAAAAACMO}
00165                             prevToken = processOptionOrDefinition(argv[idxArgument], prevToken); \par
{\bkmkstart AAAAAAACMP}{\bkmkend AAAAAAACMP}
00166                             {\cf19 break};\par
{\bkmkstart AAAAAAACMQ}{\bkmkend AAAAAAACMQ}
00167                        {\cf19 case} FLAG_ACTIVE:           \par
{\bkmkstart AAAAAAACMR}{\bkmkend AAAAAAACMR}
00168                             activeFlag   (argv[idxArgument], prevToken); \par
{\bkmkstart AAAAAAACMS}{\bkmkend AAAAAAACMS}
00169                             prevToken = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACMT}{\bkmkend AAAAAAACMT}
00170                             {\cf19 break};\par
{\bkmkstart AAAAAAACMU}{\bkmkend AAAAAAACMU}
00171                        {\cf19 case} FLAG_INACTIVE:   \par
{\bkmkstart AAAAAAACMV}{\bkmkend AAAAAAACMV}
00172                             {\cf19 if} (!updateFlagHelp(argv[idxArgument], prevToken)) \{\par
{\bkmkstart AAAAAAACMW}{\bkmkend AAAAAAACMW}
00173                                 inactiveFlag (argv[idxArgument], prevToken); \par
{\bkmkstart AAAAAAACMX}{\bkmkend AAAAAAACMX}
00174                             \}\par
{\bkmkstart AAAAAAACMY}{\bkmkend AAAAAAACMY}
00175                             prevToken = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACMZ}{\bkmkend AAAAAAACMZ}
00176                             {\cf19 break};\par
{\bkmkstart AAAAAAACNA}{\bkmkend AAAAAAACNA}
00177                       {\cf19 default}:                 \par
{\bkmkstart AAAAAAACNB}{\bkmkend AAAAAAACNB}
00178                            {\cf19 if} (prevToken == {\cf17 nullptr}) \par
{\bkmkstart AAAAAAACNC}{\bkmkend AAAAAAACNC}
00179                                addToInputs(argv[idxArgument]);\par
{\bkmkstart AAAAAAACND}{\bkmkend AAAAAAACND}
00180                            {\cf19 if} (prevToken != {\cf17 nullptr}) \{\par
{\bkmkstart AAAAAAACNE}{\bkmkend AAAAAAACNE}
00181                                addValueToOption(argv[idxArgument], prevToken);\par
{\bkmkstart AAAAAAACNF}{\bkmkend AAAAAAACNF}
00182                                prevToken = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACNG}{\bkmkend AAAAAAACNG}
00183                            \}\par
{\bkmkstart AAAAAAACNH}{\bkmkend AAAAAAACNH}
00184                \}\par
{\bkmkstart AAAAAAACNI}{\bkmkend AAAAAAACNI}
00185          \}\par
{\bkmkstart AAAAAAACNJ}{\bkmkend AAAAAAACNJ}
00186         launchHelpIfActive({\cf17 this});\par
{\bkmkstart AAAAAAACNK}{\bkmkend AAAAAAACNK}
00187     \}\par
{\bkmkstart AAAAAAACNL}{\bkmkend AAAAAAACNL}
00188     {\cf18 char}* CommandLine::processOptionOrDefinition({\cf17 const} {\cf18 char} *argv, {\cf18 char} *prevToken) \{\par
{\bkmkstart AAAAAAACNM}{\bkmkend AAAAAAACNM}
00189          {\cf18 char} *optionName;\par
{\bkmkstart AAAAAAACNN}{\bkmkend AAAAAAACNN}
00190          {\cf18 size_t} pos = std::string(argv).find({\cf22 "="});\par
{\bkmkstart AAAAAAACNO}{\bkmkend AAAAAAACNO}
00191          {\cf19 if} (pos != std::string::npos) {\cf19 return} processDefinition(argv);\par
{\bkmkstart AAAAAAACNP}{\bkmkend AAAAAAACNP}
00192          validateEntry(argv, prevToken);\par
{\bkmkstart AAAAAAACNQ}{\bkmkend AAAAAAACNQ}
00193          optionName = checkOption(&(argv[1]));\par
{\bkmkstart AAAAAAACNR}{\bkmkend AAAAAAACNR}
00194          {\cf19 if} (strict) checkAlreadySet(&options, prevToken);\par
{\bkmkstart AAAAAAACNS}{\bkmkend AAAAAAACNS}
00195          {\cf19 return} optionName;\par
{\bkmkstart AAAAAAACNT}{\bkmkend AAAAAAACNT}
00196    \}\par
{\bkmkstart AAAAAAACNU}{\bkmkend AAAAAAACNU}
00197     {\cf18 char}* CommandLine::processDefinition({\cf17 const} {\cf18 char} *argv) \{\par
{\bkmkstart AAAAAAACNV}{\bkmkend AAAAAAACNV}
00198          {\cf17 const} {\cf18 char}* ptr = &(argv[1]);\par
{\bkmkstart AAAAAAACNW}{\bkmkend AAAAAAACNW}
00199          vector<string> toks = tokenize(ptr, {\cf22 "="});\par
{\bkmkstart AAAAAAACNX}{\bkmkend AAAAAAACNX}
00200          {\cf19 if} (toks.size() != 2)      {\cf19 throw} cmdline::CmdLineParameterException(INV_DEFINITION, argv);\par
{\bkmkstart AAAAAAACNY}{\bkmkend AAAAAAACNY}
00201          {\cf19 if} (toks[0].length() == 0) {\cf19 throw} cmdline::CmdLineParameterException(INV_DEFINITION, argv);\par
{\bkmkstart AAAAAAACNZ}{\bkmkend AAAAAAACNZ}
00202          Argument* def = defines.find(toks[0]);\par
{\bkmkstart AAAAAAACOA}{\bkmkend AAAAAAACOA}
00203          {\cf19 if} (def == {\cf17 nullptr}) def = {\cf17 new} Define(toks[0].c_str());\par
{\bkmkstart AAAAAAACOB}{\bkmkend AAAAAAACOB}
00204          def->addValues(splitArgument(toks[1].c_str()));\par
{\bkmkstart AAAAAAACOC}{\bkmkend AAAAAAACOC}
00205          defines.add(def);\par
{\bkmkstart AAAAAAACOD}{\bkmkend AAAAAAACOD}
00206          {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACOE}{\bkmkend AAAAAAACOE}
00207    \}\par
{\bkmkstart AAAAAAACOF}{\bkmkend AAAAAAACOF}
00208     {\cf18 char}* CommandLine::activeFlag({\cf17 const} {\cf18 char} *flag, {\cf18 char} *prev) \{\par
{\bkmkstart AAAAAAACOG}{\bkmkend AAAAAAACOG}
00209          std::vector<std::string> flags = splitArgument(flag);\par
{\bkmkstart AAAAAAACOH}{\bkmkend AAAAAAACOH}
00210          {\cf19 for} (std::string f : flags) updateFlagItem(({\cf18 char}*)f.c_str(), prev, {\cf17 true});\par
{\bkmkstart AAAAAAACOI}{\bkmkend AAAAAAACOI}
00211          {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACOJ}{\bkmkend AAAAAAACOJ}
00212    \}\par
{\bkmkstart AAAAAAACOK}{\bkmkend AAAAAAACOK}
00213     {\cf18 char}* CommandLine::inactiveFlag({\cf17 const} {\cf18 char} *flag, {\cf18 char} *prev) \{\par
{\bkmkstart AAAAAAACOL}{\bkmkend AAAAAAACOL}
00214          std::vector<std::string> flags = splitArgument(flag);\par
{\bkmkstart AAAAAAACOM}{\bkmkend AAAAAAACOM}
00215          {\cf19 for} (std::string f : flags) updateFlagItem(({\cf18 char}*)f.c_str(), prev, {\cf17 false});\par
{\bkmkstart AAAAAAACON}{\bkmkend AAAAAAACON}
00216          {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACOO}{\bkmkend AAAAAAACOO}
00217    \}\par
{\bkmkstart AAAAAAACOP}{\bkmkend AAAAAAACOP}
00218     {\cf18 void}  CommandLine::updateFlagItem({\cf17 const} {\cf18 char}* flag, {\cf17 const} {\cf18 char}* prev, {\cf18 bool} value) \{\par
{\bkmkstart AAAAAAACOQ}{\bkmkend AAAAAAACOQ}
00219           std::string name;\par
{\bkmkstart AAAAAAACOR}{\bkmkend AAAAAAACOR}
00220           validateEntry(flag, prev);\par
{\bkmkstart AAAAAAACOS}{\bkmkend AAAAAAACOS}
00221           {\cf19 try} \{\par
{\bkmkstart AAAAAAACOT}{\bkmkend AAAAAAACOT}
00222              Argument* opt = flags.find(checkFlag(&(flag[1])));\par
{\bkmkstart AAAAAAACOU}{\bkmkend AAAAAAACOU}
00223              opt->setValue(value);\par
{\bkmkstart AAAAAAACOV}{\bkmkend AAAAAAACOV}
00224           \}\par
{\bkmkstart AAAAAAACOW}{\bkmkend AAAAAAACOW}
00225           {\cf19 catch} (exception ex) \{\par
{\bkmkstart AAAAAAACOX}{\bkmkend AAAAAAACOX}
00226              {\cf18 char} newFlag[3] = {\cf22 "+ "};\par
{\bkmkstart AAAAAAACOY}{\bkmkend AAAAAAACOY}
00227              {\cf19 if} (strlen(flag) == 2) {\cf19 throw};\par
{\bkmkstart AAAAAAACOZ}{\bkmkend AAAAAAACOZ}
00228              {\cf19 for} ({\cf18 size_t} i = 1; i < strlen(flag); i++) \{\par
{\bkmkstart AAAAAAACPA}{\bkmkend AAAAAAACPA}
00229                   newFlag[1] = flag[i];\par
{\bkmkstart AAAAAAACPB}{\bkmkend AAAAAAACPB}
00230                   updateFlagItem(newFlag, prev, value);\par
{\bkmkstart AAAAAAACPC}{\bkmkend AAAAAAACPC}
00231              \}\par
{\bkmkstart AAAAAAACPD}{\bkmkend AAAAAAACPD}
00232           \}\par
{\bkmkstart AAAAAAACPE}{\bkmkend AAAAAAACPE}
00233     \}\par
{\bkmkstart AAAAAAACPF}{\bkmkend AAAAAAACPF}
00234     {\cf18 void}  CommandLine::addToInputs({\cf17 const} {\cf18 char} *arg) \{\par
{\bkmkstart AAAAAAACPG}{\bkmkend AAAAAAACPG}
00235             inputs.push_back(strdup(arg));\par
{\bkmkstart AAAAAAACPH}{\bkmkend AAAAAAACPH}
00236     \}\par
{\bkmkstart AAAAAAACPI}{\bkmkend AAAAAAACPI}
00237     {\cf18 char}* CommandLine::addValueToOption({\cf17 const} {\cf18 char}* value, {\cf18 char}* option) \{\par
{\bkmkstart AAAAAAACPJ}{\bkmkend AAAAAAACPJ}
00238          {\cf19 if} (strlen(option) == 1) {\cf19 throw} CmdLineException(ERR_INV_OPTION, option);\par
{\bkmkstart AAAAAAACPK}{\bkmkend AAAAAAACPK}
00239          Argument* opt = options.find(option); {\cf20 // Exists!!!!}\par
{\bkmkstart AAAAAAACPL}{\bkmkend AAAAAAACPL}
00240          validateValue(value, opt->type);\par
{\bkmkstart AAAAAAACPM}{\bkmkend AAAAAAACPM}
00241          {\cf19 if} (opt->multiple)  (*opt).addValue(value);\par
{\bkmkstart AAAAAAACPN}{\bkmkend AAAAAAACPN}
00242          {\cf19 if} (!opt->multiple) (*opt).setValue(value);\par
{\bkmkstart AAAAAAACPO}{\bkmkend AAAAAAACPO}
00243          {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACPP}{\bkmkend AAAAAAACPP}
00244    \}\par
{\bkmkstart AAAAAAACPQ}{\bkmkend AAAAAAACPQ}
00245 \par
{\bkmkstart AAAAAAACPR}{\bkmkend AAAAAAACPR}
00246     {\cf18 char}* CommandLine::updateOption({\cf17 const} {\cf18 char}* option, {\cf18 char}* prev) \{\par
{\bkmkstart AAAAAAACPS}{\bkmkend AAAAAAACPS}
00247           {\cf18 size_t} pos = std::string(option).find({\cf22 "="});\par
{\bkmkstart AAAAAAACPT}{\bkmkend AAAAAAACPT}
00248           {\cf19 if} (pos != std::string::npos) {\cf19 return} updateDefinition(option);\par
{\bkmkstart AAAAAAACPU}{\bkmkend AAAAAAACPU}
00249           validateEntry(option, prev);\par
{\bkmkstart AAAAAAACPV}{\bkmkend AAAAAAACPV}
00250           {\cf19 return} (checkOption(&(option[1])));\par
{\bkmkstart AAAAAAACPW}{\bkmkend AAAAAAACPW}
00251     \}\par
{\bkmkstart AAAAAAACPX}{\bkmkend AAAAAAACPX}
00252     {\cf18 char}* CommandLine::updateDefinition({\cf17 const} {\cf18 char}* value) \{\par
{\bkmkstart AAAAAAACPY}{\bkmkend AAAAAAACPY}
00253           {\cf17 const} {\cf18 char}* ptr = &(value[1]);\par
{\bkmkstart AAAAAAACPZ}{\bkmkend AAAAAAACPZ}
00254           vector<string> toks = tokenize(ptr, {\cf22 "="});\par
{\bkmkstart AAAAAAACQA}{\bkmkend AAAAAAACQA}
00255           {\cf19 if} (toks.size() != 2)      {\cf19 throw} CmdLineParameterException(INV_DEFINITION, value);\par
{\bkmkstart AAAAAAACQB}{\bkmkend AAAAAAACQB}
00256           {\cf19 if} (toks[0].length() == 0) {\cf19 throw} CmdLineParameterException(INV_DEFINITION, value);\par
{\bkmkstart AAAAAAACQC}{\bkmkend AAAAAAACQC}
00257           Argument* def = defines.find(toks[0]);\par
{\bkmkstart AAAAAAACQD}{\bkmkend AAAAAAACQD}
00258           {\cf19 if} (def == {\cf17 nullptr}) def = {\cf17 new} Define(toks[0].c_str());\par
{\bkmkstart AAAAAAACQE}{\bkmkend AAAAAAACQE}
00259           def->addValues(splitArgument(toks[1].c_str()));\par
{\bkmkstart AAAAAAACQF}{\bkmkend AAAAAAACQF}
00260           defines.add(def);\par
{\bkmkstart AAAAAAACQG}{\bkmkend AAAAAAACQG}
00261           {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACQH}{\bkmkend AAAAAAACQH}
00262     \}\par
{\bkmkstart AAAAAAACQI}{\bkmkend AAAAAAACQI}
00263     {\cf18 char}* CommandLine::updateFlag({\cf17 const} {\cf18 char}* flag, {\cf17 const} {\cf18 char}* prev, {\cf18 bool} value) \{\par
{\bkmkstart AAAAAAACQJ}{\bkmkend AAAAAAACQJ}
00264         std::vector<std::string> flags = splitArgument(flag);\par
{\bkmkstart AAAAAAACQK}{\bkmkend AAAAAAACQK}
00265         {\cf19 for} (std::string f : flags)\par
{\bkmkstart AAAAAAACQL}{\bkmkend AAAAAAACQL}
00266             updateFlagItem(({\cf18 char}*)f.c_str(), prev, value);\par
{\bkmkstart AAAAAAACQM}{\bkmkend AAAAAAACQM}
00267         {\cf19 return} {\cf17 nullptr};\par
{\bkmkstart AAAAAAACQN}{\bkmkend AAAAAAACQN}
00268     \}\par
{\bkmkstart AAAAAAACQO}{\bkmkend AAAAAAACQO}
00269 \par
{\bkmkstart AAAAAAACQP}{\bkmkend AAAAAAACQP}
00270     Flags CommandLine::getFlags({\cf18 bool} active, {\cf18 bool} defaultValues) \{\par
{\bkmkstart AAAAAAACQQ}{\bkmkend AAAAAAACQQ}
00271           Flags act;\par
{\bkmkstart AAAAAAACQR}{\bkmkend AAAAAAACQR}
00272           {\cf18 bool} value;\par
{\bkmkstart AAAAAAACQS}{\bkmkend AAAAAAACQS}
00273           {\cf19 for} ({\cf17 auto} it : flags) \{\par
{\bkmkstart AAAAAAACQT}{\bkmkend AAAAAAACQT}
00274             value = makeBoolean((defaultValues) ? it.second.defValue : it.second.getValue());\par
{\bkmkstart AAAAAAACQU}{\bkmkend AAAAAAACQU}
00275             {\cf19 if} (it.second.source != Source::AUTO && (active || value)) act.emplace(it.second.name, value);\par
{\bkmkstart AAAAAAACQV}{\bkmkend AAAAAAACQV}
00276           \}\par
{\bkmkstart AAAAAAACQW}{\bkmkend AAAAAAACQW}
00277           {\cf19 return} act;\par
{\bkmkstart AAAAAAACQX}{\bkmkend AAAAAAACQX}
00278     \}\par
{\bkmkstart AAAAAAACQY}{\bkmkend AAAAAAACQY}
00279 \par
{\bkmkstart AAAAAAACQZ}{\bkmkend AAAAAAACQZ}
00280     Argument& CommandLine::find(Group* group, {\cf17 const} {\cf18 char}* what) \{\par
{\bkmkstart AAAAAAACRA}{\bkmkend AAAAAAACRA}
00281          {\cf18 char}* ptr = ({\cf18 char}*)what;\par
{\bkmkstart AAAAAAACRB}{\bkmkend AAAAAAACRB}
00282          {\cf19 if} (sensitive) ptr = makeUpper(what);\par
{\bkmkstart AAAAAAACRC}{\bkmkend AAAAAAACRC}
00283          Argument* arg = group->find(ptr);\par
{\bkmkstart AAAAAAACRD}{\bkmkend AAAAAAACRD}
00284          {\cf19 if} (arg == {\cf17 nullptr}) {\cf19 throw} CmdLineNotFoundException(ERR_NOT_FND, what);\par
{\bkmkstart AAAAAAACRE}{\bkmkend AAAAAAACRE}
00285          {\cf19 return} *arg;\par
{\bkmkstart AAAAAAACRF}{\bkmkend AAAAAAACRF}
00286     \}\par
{\bkmkstart AAAAAAACRG}{\bkmkend AAAAAAACRG}
00287     Argument* CommandLine::findPointer(Group* group, {\cf17 const} {\cf18 char}* what) \{\par
{\bkmkstart AAAAAAACRH}{\bkmkend AAAAAAACRH}
00288          {\cf18 char}* ptr = ({\cf18 char}*)what;\par
{\bkmkstart AAAAAAACRI}{\bkmkend AAAAAAACRI}
00289          {\cf19 if} (sensitive) ptr = makeUpper(what);\par
{\bkmkstart AAAAAAACRJ}{\bkmkend AAAAAAACRJ}
00290          {\cf19 return} group->find(ptr);\par
{\bkmkstart AAAAAAACRK}{\bkmkend AAAAAAACRK}
00291     \}\par
{\bkmkstart AAAAAAACRL}{\bkmkend AAAAAAACRL}
00292 \par
{\bkmkstart AAAAAAACRM}{\bkmkend AAAAAAACRM}
00293     {\cf17 const} {\cf18 char}* CommandLine::getValue(Group* grp, {\cf17 const} {\cf18 char}* name) \{\par
{\bkmkstart AAAAAAACRN}{\bkmkend AAAAAAACRN}
00294         Argument& opt = find(grp, name);\par
{\bkmkstart AAAAAAACRO}{\bkmkend AAAAAAACRO}
00295         {\cf19 return} opt.getValue();\par
{\bkmkstart AAAAAAACRP}{\bkmkend AAAAAAACRP}
00296     \}\par
{\bkmkstart AAAAAAACRQ}{\bkmkend AAAAAAACRQ}
00297     {\cf18 void}  CommandLine::loadParameters(Parameters parms) \{\par
{\bkmkstart AAAAAAACRR}{\bkmkend AAAAAAACRR}
00298         ParameterTree** root;\par
{\bkmkstart AAAAAAACRS}{\bkmkend AAAAAAACRS}
00299 \par
{\bkmkstart AAAAAAACRT}{\bkmkend AAAAAAACRT}
00300         {\cf19 for} (Parm p : parms) \{\par
{\bkmkstart AAAAAAACRU}{\bkmkend AAAAAAACRU}
00301             Argument option(&p);\par
{\bkmkstart AAAAAAACRV}{\bkmkend AAAAAAACRV}
00302             {\cf19 if} (sensitive) option.makeUpper();\par
{\bkmkstart AAAAAAACRW}{\bkmkend AAAAAAACRW}
00303             {\cf18 bool} isFlag = (p.instanceOfFlag() || p.type == Type::FLAG) ? {\cf17 true} : {\cf17 false};\par
{\bkmkstart AAAAAAACRX}{\bkmkend AAAAAAACRX}
00304             Group* map = (isFlag) ? &flags : &options;\par
{\bkmkstart AAAAAAACRY}{\bkmkend AAAAAAACRY}
00305             root       = (isFlag) ? rootFlags : rootOptions;\par
{\bkmkstart AAAAAAACRZ}{\bkmkend AAAAAAACRZ}
00306             map->add(option.name, &option);\par
{\bkmkstart AAAAAAACSA}{\bkmkend AAAAAAACSA}
00307             add2tree(root, option.name.c_str());\par
{\bkmkstart AAAAAAACSB}{\bkmkend AAAAAAACSB}
00308         \}\par
{\bkmkstart AAAAAAACSC}{\bkmkend AAAAAAACSC}
00309     \}\par
{\bkmkstart AAAAAAACSD}{\bkmkend AAAAAAACSD}
00310     {\cf18 void}  CommandLine::loadHelpFlags() \{\par
{\bkmkstart AAAAAAACSE}{\bkmkend AAAAAAACSE}
00311         Parameters flagsHelp = \{ Parm({\cf22 "help"}, {\cf17 false}) ,Parm({\cf22 "HELP"}, {\cf17 false}) \};\par
{\bkmkstart AAAAAAACSF}{\bkmkend AAAAAAACSF}
00312         Argument* arg = flags.find({\cf22 "help"});\par
{\bkmkstart AAAAAAACSG}{\bkmkend AAAAAAACSG}
00313         {\cf19 if} (arg != {\cf17 nullptr}) {\cf19 return};\par
{\bkmkstart AAAAAAACSH}{\bkmkend AAAAAAACSH}
00314         loadParameters(flagsHelp);\par
{\bkmkstart AAAAAAACSI}{\bkmkend AAAAAAACSI}
00315         {\cf19 if} (!sensitive) \{\par
{\bkmkstart AAAAAAACSJ}{\bkmkend AAAAAAACSJ}
00316             arg = flags.find({\cf22 "help"});\par
{\bkmkstart AAAAAAACSK}{\bkmkend AAAAAAACSK}
00317             arg->source = Source::AUTO;\par
{\bkmkstart AAAAAAACSL}{\bkmkend AAAAAAACSL}
00318         \}\par
{\bkmkstart AAAAAAACSM}{\bkmkend AAAAAAACSM}
00319         arg = flags.find({\cf22 "HELP"});\par
{\bkmkstart AAAAAAACSN}{\bkmkend AAAAAAACSN}
00320         arg->source = Source::AUTO;\par
{\bkmkstart AAAAAAACSO}{\bkmkend AAAAAAACSO}
00321     \}\par
{\bkmkstart AAAAAAACSP}{\bkmkend AAAAAAACSP}
00322     {\cf18 void}  CommandLine::updateValuesFromEnvironment() \{\par
{\bkmkstart AAAAAAACSQ}{\bkmkend AAAAAAACSQ}
00323         {\cf18 char} key[255];\par
{\bkmkstart AAAAAAACSR}{\bkmkend AAAAAAACSR}
00324         {\cf18 char}* p = ({\cf18 char}*){\cf22 ""};\par
{\bkmkstart AAAAAAACSS}{\bkmkend AAAAAAACSS}
00325         Argument* arg = options.find(ENV_PREFFIX);\par
{\bkmkstart AAAAAAACST}{\bkmkend AAAAAAACST}
00326         {\cf19 if} (arg != {\cf17 nullptr}) \{\par
{\bkmkstart AAAAAAACSU}{\bkmkend AAAAAAACSU}
00327             sprintf(key, {\cf22 "%s_"}, arg->name.c_str());\par
{\bkmkstart AAAAAAACSV}{\bkmkend AAAAAAACSV}
00328             p = strdup(key);\par
{\bkmkstart AAAAAAACSW}{\bkmkend AAAAAAACSW}
00329         \}\par
{\bkmkstart AAAAAAACSX}{\bkmkend AAAAAAACSX}
00330         udpateArgsFromEnv(options, p);\par
{\bkmkstart AAAAAAACSY}{\bkmkend AAAAAAACSY}
00331         udpateArgsFromEnv(flags, p);\par
{\bkmkstart AAAAAAACSZ}{\bkmkend AAAAAAACSZ}
00332         {\cf19 if} (arg != {\cf17 nullptr}) free(p);\par
{\bkmkstart AAAAAAACTA}{\bkmkend AAAAAAACTA}
00333     \}\par
{\bkmkstart AAAAAAACTB}{\bkmkend AAAAAAACTB}
00334     {\cf18 void}  CommandLine::udpateArgsFromEnv(Group& parms, {\cf17 const} {\cf18 char}* prfx) \{\par
{\bkmkstart AAAAAAACTC}{\bkmkend AAAAAAACTC}
00335         {\cf18 char} key[255];\par
{\bkmkstart AAAAAAACTD}{\bkmkend AAAAAAACTD}
00336         {\cf18 char}* value;\par
{\bkmkstart AAAAAAACTE}{\bkmkend AAAAAAACTE}
00337         {\cf19 for} ({\cf17 auto} it = parms.begin(); it != parms.end(); it++) \{\par
{\bkmkstart AAAAAAACTF}{\bkmkend AAAAAAACTF}
00338             sprintf(key, {\cf22 "%s%s"}, prfx, it->second.name.c_str());\par
{\bkmkstart AAAAAAACTG}{\bkmkend AAAAAAACTG}
00339             value = getenv(key);\par
{\bkmkstart AAAAAAACTH}{\bkmkend AAAAAAACTH}
00340             {\cf19 if} (value != {\cf17 nullptr}) it->second.setFromEnv(value);\par
{\bkmkstart AAAAAAACTI}{\bkmkend AAAAAAACTI}
00341         \}\par
{\bkmkstart AAAAAAACTJ}{\bkmkend AAAAAAACTJ}
00342     \}\par
{\bkmkstart AAAAAAACTK}{\bkmkend AAAAAAACTK}
00343     {\cf18 void}  CommandLine::checkAlreadySet(Group* group, {\cf17 const} {\cf18 char}* what) \{\par
{\bkmkstart AAAAAAACTL}{\bkmkend AAAAAAACTL}
00344         Argument* arg = findPointer(group, what);\par
{\bkmkstart AAAAAAACTM}{\bkmkend AAAAAAACTM}
00345         {\cf19 if} (arg != {\cf17 nullptr} && (arg->values.size() && !arg->multiple)) \{\par
{\bkmkstart AAAAAAACTN}{\bkmkend AAAAAAACTN}
00346                 {\cf19 throw} CmdLineDuplicateArgumentException(ERR_ARG_DUP, what);\par
{\bkmkstart AAAAAAACTO}{\bkmkend AAAAAAACTO}
00347         \}\par
{\bkmkstart AAAAAAACTP}{\bkmkend AAAAAAACTP}
00348     \}\par
{\bkmkstart AAAAAAACTQ}{\bkmkend AAAAAAACTQ}
00349     {\cf18 char}* CommandLine::checkOption({\cf17 const} {\cf18 char}* option) \{ {\cf19 return} (checkParameter(rootOptions, option)); \}\par
{\bkmkstart AAAAAAACTR}{\bkmkend AAAAAAACTR}
00350     {\cf18 char}* CommandLine::checkFlag({\cf17 const} {\cf18 char}* flag)     \{ {\cf19 return} (checkParameter(rootFlags, flag)); \}\par
{\bkmkstart AAAAAAACTS}{\bkmkend AAAAAAACTS}
00351     {\cf18 char}* CommandLine::checkParameter(ParameterTree* root[], {\cf17 const} {\cf18 char}* parm) \{\par
{\bkmkstart AAAAAAACTT}{\bkmkend AAAAAAACTT}
00352         {\cf18 size_t} idx = 0;\par
{\bkmkstart AAAAAAACTU}{\bkmkend AAAAAAACTU}
00353         ParameterTree* base = root[parm[0] - {\cf23 ' '}];\par
{\bkmkstart AAAAAAACTV}{\bkmkend AAAAAAACTV}
00354         ParameterTree* prev = {\cf17 nullptr};\par
{\bkmkstart AAAAAAACTW}{\bkmkend AAAAAAACTW}
00355 \par
{\bkmkstart AAAAAAACTX}{\bkmkend AAAAAAACTX}
00356         {\cf19 while} (idx < strlen(parm) && base != {\cf17 nullptr}) \{\par
{\bkmkstart AAAAAAACTY}{\bkmkend AAAAAAACTY}
00357                 prev = base;\par
{\bkmkstart AAAAAAACTZ}{\bkmkend AAAAAAACTZ}
00358                 {\cf19 if} (base->letter != parm[idx]) {\cf19 break};\par
{\bkmkstart AAAAAAACUA}{\bkmkend AAAAAAACUA}
00359                 base = base->getChild(parm[++idx]);\par
{\bkmkstart AAAAAAACUB}{\bkmkend AAAAAAACUB}
00360         \}\par
{\bkmkstart AAAAAAACUC}{\bkmkend AAAAAAACUC}
00361 \par
{\bkmkstart AAAAAAACUD}{\bkmkend AAAAAAACUD}
00362         std::string str;\par
{\bkmkstart AAAAAAACUE}{\bkmkend AAAAAAACUE}
00363         {\cf19 if} (idx == strlen(parm)) \{ {\cf20 // Parsing full done}\par
{\bkmkstart AAAAAAACUF}{\bkmkend AAAAAAACUF}
00364         {\cf19 switch} (prev->numChildren()) \{\par
{\bkmkstart AAAAAAACUG}{\bkmkend AAAAAAACUG}
00365             {\cf19 case} 0: {\cf19 return} (strdup(parm));\par
{\bkmkstart AAAAAAACUH}{\bkmkend AAAAAAACUH}
00366             {\cf19 case} 1: str = parm;\par
{\bkmkstart AAAAAAACUI}{\bkmkend AAAAAAACUI}
00367                     str.append(prev->getNext()->getWord());\par
{\bkmkstart AAAAAAACUJ}{\bkmkend AAAAAAACUJ}
00368                     {\cf19 return} (makeChar(str));\par
{\bkmkstart AAAAAAACUK}{\bkmkend AAAAAAACUK}
00369             {\cf19 default}: {\cf19 throw} CmdLineParameterException(ERR_ARG_ERR, parm);\par
{\bkmkstart AAAAAAACUL}{\bkmkend AAAAAAACUL}
00370         \}\par
{\bkmkstart AAAAAAACUM}{\bkmkend AAAAAAACUM}
00371             \}\par
{\bkmkstart AAAAAAACUN}{\bkmkend AAAAAAACUN}
00372             {\cf19 if} (prev == {\cf17 nullptr}) {\cf19 throw} CmdLineException(TXT_ARG_NFND, parm);  {\cf20 // primero}\par
{\bkmkstart AAAAAAACUO}{\bkmkend AAAAAAACUO}
00373             {\cf19 if} (idx < strlen(parm) && prev->branchs == 0) \{ {\cf20 // overtype}\par
{\bkmkstart AAAAAAACUP}{\bkmkend AAAAAAACUP}
00374                 {\cf19 throw} CmdLineException(TXT_ARG_NFND1, parm, prev->getReversedWord());\par
{\bkmkstart AAAAAAACUQ}{\bkmkend AAAAAAACUQ}
00375             \}\par
{\bkmkstart AAAAAAACUR}{\bkmkend AAAAAAACUR}
00376             {\cf20 // Ha salido por base = nullptr}\par
{\bkmkstart AAAAAAACUS}{\bkmkend AAAAAAACUS}
00377 \par
{\bkmkstart AAAAAAACUT}{\bkmkend AAAAAAACUT}
00378             {\cf19 if} (prev->branchs == 1) \{\par
{\bkmkstart AAAAAAACUU}{\bkmkend AAAAAAACUU}
00379                 {\cf18 char}* next = prev->getWord();\par
{\bkmkstart AAAAAAACUV}{\bkmkend AAAAAAACUV}
00380                 {\cf18 char}* base = prev->getReversedWord();\par
{\bkmkstart AAAAAAACUW}{\bkmkend AAAAAAACUW}
00381                 base[strlen(base) - 1] = 0x0;\par
{\bkmkstart AAAAAAACUX}{\bkmkend AAAAAAACUX}
00382                 {\cf19 throw} CmdLineException(TXT_ARG_NFND2, parm, base, next);\par
{\bkmkstart AAAAAAACUY}{\bkmkend AAAAAAACUY}
00383             \}\par
{\bkmkstart AAAAAAACUZ}{\bkmkend AAAAAAACUZ}
00384             {\cf19 if} (prev->branchs > 1) \{\par
{\bkmkstart AAAAAAACVA}{\bkmkend AAAAAAACVA}
00385                 {\cf19 throw} CmdLineException(TXT_ARG_NFND3, parm);\par
{\bkmkstart AAAAAAACVB}{\bkmkend AAAAAAACVB}
00386             \}\par
{\bkmkstart AAAAAAACVC}{\bkmkend AAAAAAACVC}
00387             {\cf20 //      if (base == nullptr) throw CmdLineParameterException(parm, prev->getReversedWord());}\par
{\bkmkstart AAAAAAACVD}{\bkmkend AAAAAAACVD}
00388 \par
{\bkmkstart AAAAAAACVE}{\bkmkend AAAAAAACVE}
00389             std::string ss(parm);\par
{\bkmkstart AAAAAAACVF}{\bkmkend AAAAAAACVF}
00390             ss.append(base->getWord());\par
{\bkmkstart AAAAAAACVG}{\bkmkend AAAAAAACVG}
00391             {\cf19 return} (makeChar(ss));\par
{\bkmkstart AAAAAAACVH}{\bkmkend AAAAAAACVH}
00392         \}\par
{\bkmkstart AAAAAAACVI}{\bkmkend AAAAAAACVI}
00393 \par
{\bkmkstart AAAAAAACVJ}{\bkmkend AAAAAAACVJ}
00394     {\cf18 void}  CommandLine::processConfigFile ({\cf18 char} *fname) \{\par
{\bkmkstart AAAAAAACVK}{\bkmkend AAAAAAACVK}
00395     \}\par
{\bkmkstart AAAAAAACVL}{\bkmkend AAAAAAACVL}
00396     {\cf18 bool}  CommandLine::updateFlagHelp    ({\cf17 const} {\cf18 char} *arg, {\cf18 char} *prev) \{\par
{\bkmkstart AAAAAAACVM}{\bkmkend AAAAAAACVM}
00397          {\cf18 char} *flag = checkKeywordHelp(arg);\par
{\bkmkstart AAAAAAACVN}{\bkmkend AAAAAAACVN}
00398          {\cf19 if} (flag == {\cf17 nullptr}) {\cf19 return} {\cf17 false};\par
{\bkmkstart AAAAAAACVO}{\bkmkend AAAAAAACVO}
00399          updateFlag(flag, prev, {\cf17 true});\par
{\bkmkstart AAAAAAACVP}{\bkmkend AAAAAAACVP}
00400          {\cf19 return} {\cf17 true};\par
{\bkmkstart AAAAAAACVQ}{\bkmkend AAAAAAACVQ}
00401     \}\par
{\bkmkstart AAAAAAACVR}{\bkmkend AAAAAAACVR}
00402 \}\par
{\bkmkstart AAAAAAACVS}{\bkmkend AAAAAAACVS}
00403 {\cf20 /*}\par
{\bkmkstart AAAAAAACVT}{\bkmkend AAAAAAACVT}
00404 {\cf20 #include <iostream> // temp}\par
{\bkmkstart AAAAAAACVU}{\bkmkend AAAAAAACVU}
00405 {\cf20 #include <type_traits>}\par
{\bkmkstart AAAAAAACVV}{\bkmkend AAAAAAACVV}
00406 {\cf20 #include <chrono>}\par
{\bkmkstart AAAAAAACVW}{\bkmkend AAAAAAACVW}
00407 {\cf20 #include <any>}\par
{\bkmkstart AAAAAAACVX}{\bkmkend AAAAAAACVX}
00408 {\cf20 #include <utility>}\par
{\bkmkstart AAAAAAACVY}{\bkmkend AAAAAAACVY}
00409 {\cf20 }\par
{\bkmkstart AAAAAAACVZ}{\bkmkend AAAAAAACVZ}
00410 {\cf20 #include "parameter_tree.hpp"}\par
{\bkmkstart AAAAAAACWA}{\bkmkend AAAAAAACWA}
00411 {\cf20 }\par
{\bkmkstart AAAAAAACWB}{\bkmkend AAAAAAACWB}
00412 {\cf20 #include "tools.h"}\par
{\bkmkstart AAAAAAACWC}{\bkmkend AAAAAAACWC}
00413 {\cf20 #include "defines.hpp"}\par
{\bkmkstart AAAAAAACWD}{\bkmkend AAAAAAACWD}
00414 {\cf20 #include "cmdline_exceptions.hpp"}\par
{\bkmkstart AAAAAAACWE}{\bkmkend AAAAAAACWE}
00415 {\cf20 #include "validations.h"}\par
{\bkmkstart AAAAAAACWF}{\bkmkend AAAAAAACWF}
00416 {\cf20 #include "commandline.hpp"}\par
{\bkmkstart AAAAAAACWG}{\bkmkend AAAAAAACWG}
00417 {\cf20 #include "msg_locale.h"}\par
{\bkmkstart AAAAAAACWH}{\bkmkend AAAAAAACWH}
00418 {\cf20 }\par
{\bkmkstart AAAAAAACWI}{\bkmkend AAAAAAACWI}
00419 {\cf20 //#pragma warning( disable : 4390 34; once : 4385; error : 164 )}\par
{\bkmkstart AAAAAAACWJ}{\bkmkend AAAAAAACWJ}
00420 {\cf20 }\par
{\bkmkstart AAAAAAACWK}{\bkmkend AAAAAAACWK}
00421 {\cf20 #ifdef _WIN32}\par
{\bkmkstart AAAAAAACWL}{\bkmkend AAAAAAACWL}
00422 {\cf20 #pragma warning( disable : 4390 )}\par
{\bkmkstart AAAAAAACWM}{\bkmkend AAAAAAACWM}
00423 {\cf20 #endif}\par
{\bkmkstart AAAAAAACWN}{\bkmkend AAAAAAACWN}
00424 {\cf20 }\par
{\bkmkstart AAAAAAACWO}{\bkmkend AAAAAAACWO}
00425 {\cf20 using namespace std;}\par
{\bkmkstart AAAAAAACWP}{\bkmkend AAAAAAACWP}
00426 {\cf20 using namespace cmdline;}\par
{\bkmkstart AAAAAAACWQ}{\bkmkend AAAAAAACWQ}
00427 {\cf20 }\par
{\bkmkstart AAAAAAACWR}{\bkmkend AAAAAAACWR}
00428 {\cf20 namespace _cmdline \{}\par
{\bkmkstart AAAAAAACWS}{\bkmkend AAAAAAACWS}
00429 {\cf20 }\par
{\bkmkstart AAAAAAACWT}{\bkmkend AAAAAAACWT}
00430 {\cf20    #ifndef ENV_PREFFIX}\par
{\bkmkstart AAAAAAACWU}{\bkmkend AAAAAAACWU}
00431 {\cf20        #define ENV_PREFFIX "env_preffix"}\par
{\bkmkstart AAAAAAACWV}{\bkmkend AAAAAAACWV}
00432 {\cf20     #endif}\par
{\bkmkstart AAAAAAACWW}{\bkmkend AAAAAAACWW}
00433 {\cf20 }\par
{\bkmkstart AAAAAAACWX}{\bkmkend AAAAAAACWX}
00434 {\cf20     ParameterTree* rootOptions[128];}\par
{\bkmkstart AAAAAAACWY}{\bkmkend AAAAAAACWY}
00435 {\cf20     ParameterTree* rootFlags[128];}\par
{\bkmkstart AAAAAAACWZ}{\bkmkend AAAAAAACWZ}
00436 {\cf20     char _upper[64] = "";}\par
{\bkmkstart AAAAAAACXA}{\bkmkend AAAAAAACXA}
00437 {\cf20 }\par
{\bkmkstart AAAAAAACXB}{\bkmkend AAAAAAACXB}
00438 {\cf20     char* makeUpper(const char* str) \{}\par
{\bkmkstart AAAAAAACXC}{\bkmkend AAAAAAACXC}
00439 {\cf20         size_t i;}\par
{\bkmkstart AAAAAAACXD}{\bkmkend AAAAAAACXD}
00440 {\cf20         for (i = 0; i < strlen(str); i++) _upper[i] = toupper(str[i]);}\par
{\bkmkstart AAAAAAACXE}{\bkmkend AAAAAAACXE}
00441 {\cf20         _upper[i] = 0x0;}\par
{\bkmkstart AAAAAAACXF}{\bkmkend AAAAAAACXF}
00442 {\cf20         return _upper;}\par
{\bkmkstart AAAAAAACXG}{\bkmkend AAAAAAACXG}
00443 {\cf20     \}}\par
{\bkmkstart AAAAAAACXH}{\bkmkend AAAAAAACXH}
00444 {\cf20     _CommandLine::_CommandLine(int argc,  char**  argv, Parameters parms, bool sensitive, bool strict) \{}\par
{\bkmkstart AAAAAAACXI}{\bkmkend AAAAAAACXI}
00445 {\cf20         this->sensitive = sensitive;}\par
{\bkmkstart AAAAAAACXJ}{\bkmkend AAAAAAACXJ}
00446 {\cf20         this->strict    = strict;}\par
{\bkmkstart AAAAAAACXK}{\bkmkend AAAAAAACXK}
00447 {\cf20         preInit(parms);}\par
{\bkmkstart AAAAAAACXL}{\bkmkend AAAAAAACXL}
00448 {\cf20         postInit();}\par
{\bkmkstart AAAAAAACXM}{\bkmkend AAAAAAACXM}
00449 {\cf20         parse(argc, argv);}\par
{\bkmkstart AAAAAAACXN}{\bkmkend AAAAAAACXN}
00450 {\cf20     \}}\par
{\bkmkstart AAAAAAACXO}{\bkmkend AAAAAAACXO}
00451 {\cf20     vector<const char*> _CommandLine::getArgs() \{}\par
{\bkmkstart AAAAAAACXP}{\bkmkend AAAAAAACXP}
00452 {\cf20         return inputs;}\par
{\bkmkstart AAAAAAACXQ}{\bkmkend AAAAAAACXQ}
00453 {\cf20     \}}\par
{\bkmkstart AAAAAAACXR}{\bkmkend AAAAAAACXR}
00454 {\cf20     bool _CommandLine::hasFlag(const char* name) \{}\par
{\bkmkstart AAAAAAACXS}{\bkmkend AAAAAAACXS}
00455 {\cf20         Argument& opt = find(&flags, name);}\par
{\bkmkstart AAAAAAACXT}{\bkmkend AAAAAAACXT}
00456 {\cf20         return makeBoolean(opt.getValue());}\par
{\bkmkstart AAAAAAACXU}{\bkmkend AAAAAAACXU}
00457 {\cf20     \}}\par
{\bkmkstart AAAAAAACXV}{\bkmkend AAAAAAACXV}
00458 {\cf20     Flags  _CommandLine::getDefaultFlags(bool all) \{ // Valores por defecto}\par
{\bkmkstart AAAAAAACXW}{\bkmkend AAAAAAACXW}
00459 {\cf20         return getFlags(all, false);}\par
{\bkmkstart AAAAAAACXX}{\bkmkend AAAAAAACXX}
00460 {\cf20     \}}\par
{\bkmkstart AAAAAAACXY}{\bkmkend AAAAAAACXY}
00461 {\cf20     Flags _CommandLine::getCurrentFlags(bool all) \{}\par
{\bkmkstart AAAAAAACXZ}{\bkmkend AAAAAAACXZ}
00462 {\cf20         return getFlags(all, true);}\par
{\bkmkstart AAAAAAACYA}{\bkmkend AAAAAAACYA}
00463 {\cf20     \}}\par
{\bkmkstart AAAAAAACYB}{\bkmkend AAAAAAACYB}
00464 {\cf20     bool _CommandLine::hasOption(const char* name) \{}\par
{\bkmkstart AAAAAAACYC}{\bkmkend AAAAAAACYC}
00465 {\cf20         Argument& opt = find(&options, name);}\par
{\bkmkstart AAAAAAACYD}{\bkmkend AAAAAAACYD}
00466 {\cf20         return (strlen(opt.getValue()) == 0 ? false : true);}\par
{\bkmkstart AAAAAAACYE}{\bkmkend AAAAAAACYE}
00467 {\cf20     \}}\par
{\bkmkstart AAAAAAACYF}{\bkmkend AAAAAAACYF}
00468 {\cf20     bool _CommandLine::isOptionMultiple(const char* name) \{}\par
{\bkmkstart AAAAAAACYG}{\bkmkend AAAAAAACYG}
00469 {\cf20         Argument& opt = find(&options, name);}\par
{\bkmkstart AAAAAAACYH}{\bkmkend AAAAAAACYH}
00470 {\cf20         return (opt.values.size() > 1);}\par
{\bkmkstart AAAAAAACYI}{\bkmkend AAAAAAACYI}
00471 {\cf20     \}}\par
{\bkmkstart AAAAAAACYJ}{\bkmkend AAAAAAACYJ}
00472 {\cf20     vector<const char*> _CommandLine::getOptionValues(const char* name) \{}\par
{\bkmkstart AAAAAAACYK}{\bkmkend AAAAAAACYK}
00473 {\cf20         Argument& opt = find(&options, name);}\par
{\bkmkstart AAAAAAACYL}{\bkmkend AAAAAAACYL}
00474 {\cf20         return opt.getValues();}\par
{\bkmkstart AAAAAAACYM}{\bkmkend AAAAAAACYM}
00475 {\cf20     \}}\par
{\bkmkstart AAAAAAACYN}{\bkmkend AAAAAAACYN}
00476 {\cf20     int    _CommandLine::getOptionNumValues(const char* name) \{}\par
{\bkmkstart AAAAAAACYO}{\bkmkend AAAAAAACYO}
00477 {\cf20         Argument& opt = find(&options, name);}\par
{\bkmkstart AAAAAAACYP}{\bkmkend AAAAAAACYP}
00478 {\cf20         return opt.values.size();}\par
{\bkmkstart AAAAAAACYQ}{\bkmkend AAAAAAACYQ}
00479 {\cf20     \}}\par
{\bkmkstart AAAAAAACYR}{\bkmkend AAAAAAACYR}
00480 {\cf20     const char* _CommandLine::getOption(const char* name) \{}\par
{\bkmkstart AAAAAAACYS}{\bkmkend AAAAAAACYS}
00481 {\cf20         return getValue(&options, name);}\par
{\bkmkstart AAAAAAACYT}{\bkmkend AAAAAAACYT}
00482 {\cf20     \}}\par
{\bkmkstart AAAAAAACYU}{\bkmkend AAAAAAACYU}
00483 {\cf20 }\par
{\bkmkstart AAAAAAACYV}{\bkmkend AAAAAAACYV}
00484 {\cf20     Options  _CommandLine::getDefaultOptions() \{}\par
{\bkmkstart AAAAAAACYW}{\bkmkend AAAAAAACYW}
00485 {\cf20         return getOptionsValue(true);}\par
{\bkmkstart AAAAAAACYX}{\bkmkend AAAAAAACYX}
00486 {\cf20     \}}\par
{\bkmkstart AAAAAAACYY}{\bkmkend AAAAAAACYY}
00487 {\cf20     Options _CommandLine::getCurrentOptions() \{}\par
{\bkmkstart AAAAAAACYZ}{\bkmkend AAAAAAACYZ}
00488 {\cf20         return getOptionsValue(false);}\par
{\bkmkstart AAAAAAACZA}{\bkmkend AAAAAAACZA}
00489 {\cf20     \}}\par
{\bkmkstart AAAAAAACZB}{\bkmkend AAAAAAACZB}
00490 {\cf20     bool            _CommandLine::hasDefinition(const char* name) \{}\par
{\bkmkstart AAAAAAACZC}{\bkmkend AAAAAAACZC}
00491 {\cf20         Argument* opt = findPointer(&defines, name);}\par
{\bkmkstart AAAAAAACZD}{\bkmkend AAAAAAACZD}
00492 {\cf20         return (opt == nullptr) ? false : true;}\par
{\bkmkstart AAAAAAACZE}{\bkmkend AAAAAAACZE}
00493 {\cf20     \}}\par
{\bkmkstart AAAAAAACZF}{\bkmkend AAAAAAACZF}
00494 {\cf20     bool            _CommandLine::isDefinitionMultiple(const char* name) \{ }\par
{\bkmkstart AAAAAAACZG}{\bkmkend AAAAAAACZG}
00495 {\cf20         Argument& opt = find(&defines, name);}\par
{\bkmkstart AAAAAAACZH}{\bkmkend AAAAAAACZH}
00496 {\cf20         return (opt.values.size() < 2 ? false : true);}\par
{\bkmkstart AAAAAAACZI}{\bkmkend AAAAAAACZI}
00497 {\cf20     \}}\par
{\bkmkstart AAAAAAACZJ}{\bkmkend AAAAAAACZJ}
00498 {\cf20     vector<const char  *>  _CommandLine::getDefinitionValues(const char* name) \{ }\par
{\bkmkstart AAAAAAACZK}{\bkmkend AAAAAAACZK}
00499 {\cf20         Argument& opt = find(&defines, name);}\par
{\bkmkstart AAAAAAACZL}{\bkmkend AAAAAAACZL}
00500 {\cf20         return opt.getValues();}\par
{\bkmkstart AAAAAAACZM}{\bkmkend AAAAAAACZM}
00501 {\cf20     \}}\par
{\bkmkstart AAAAAAACZN}{\bkmkend AAAAAAACZN}
00502 {\cf20 }\par
{\bkmkstart AAAAAAACZO}{\bkmkend AAAAAAACZO}
00504 {\cf20 }\par
{\bkmkstart AAAAAAACZP}{\bkmkend AAAAAAACZP}
00505 {\cf20 }\par
{\bkmkstart AAAAAAACZQ}{\bkmkend AAAAAAACZQ}
00506 {\cf20         udpateArgsFromEnv(options, p);}\par
{\bkmkstart AAAAAAACZR}{\bkmkend AAAAAAACZR}
00507 {\cf20         udpateArgsFromEnv(flags, p);}\par
{\bkmkstart AAAAAAACZS}{\bkmkend AAAAAAACZS}
00508 {\cf20         if (arg != nullptr) free(p);}\par
{\bkmkstart AAAAAAACZT}{\bkmkend AAAAAAACZT}
00509 {\cf20     \}}\par
{\bkmkstart AAAAAAACZU}{\bkmkend AAAAAAACZU}
00510 {\cf20     void  _CommandLine::udpateArgsFromEnv (Group &parms, const char*prfx) \{}\par
{\bkmkstart AAAAAAACZV}{\bkmkend AAAAAAACZV}
00511 {\cf20         char key[255];}\par
{\bkmkstart AAAAAAACZW}{\bkmkend AAAAAAACZW}
00512 {\cf20         char* value;}\par
{\bkmkstart AAAAAAACZX}{\bkmkend AAAAAAACZX}
00513 {\cf20         for (auto it = parms.begin(); it != parms.end(); it++) \{}\par
{\bkmkstart AAAAAAACZY}{\bkmkend AAAAAAACZY}
00514 {\cf20             sprintf(key, "%s%s", prfx, it->second.name.c_str());}\par
{\bkmkstart AAAAAAACZZ}{\bkmkend AAAAAAACZZ}
00515 {\cf20             value = getenv(key);}\par
{\bkmkstart AAAAAAADAA}{\bkmkend AAAAAAADAA}
00516 {\cf20             if (value != nullptr) it->second.setFromEnv(value);}\par
{\bkmkstart AAAAAAADAB}{\bkmkend AAAAAAADAB}
00517 {\cf20         \}}\par
{\bkmkstart AAAAAAADAC}{\bkmkend AAAAAAADAC}
00518 {\cf20     \}}\par
{\bkmkstart AAAAAAADAD}{\bkmkend AAAAAAADAD}
00519 {\cf20     Flags _CommandLine::getFlags          (bool active, bool def) \{}\par
{\bkmkstart AAAAAAADAE}{\bkmkend AAAAAAADAE}
00520 {\cf20         Flags act;}\par
{\bkmkstart AAAAAAADAF}{\bkmkend AAAAAAADAF}
00521 {\cf20         bool value;}\par
{\bkmkstart AAAAAAADAG}{\bkmkend AAAAAAADAG}
00522 {\cf20         for (auto it : flags) \{}\par
{\bkmkstart AAAAAAADAH}{\bkmkend AAAAAAADAH}
00523 {\cf20             value = makeBoolean((def) ? it.second.defValue : it.second.getValue());}\par
{\bkmkstart AAAAAAADAI}{\bkmkend AAAAAAADAI}
00524 {\cf20             if (it.second.source != Source::AUTO && (active || value)) act.emplace(it.second.name, value);}\par
{\bkmkstart AAAAAAADAJ}{\bkmkend AAAAAAADAJ}
00525 {\cf20         \}}\par
{\bkmkstart AAAAAAADAK}{\bkmkend AAAAAAADAK}
00526 {\cf20         return act;}\par
{\bkmkstart AAAAAAADAL}{\bkmkend AAAAAAADAL}
00527 {\cf20     \}}\par
{\bkmkstart AAAAAAADAM}{\bkmkend AAAAAAADAM}
00528 {\cf20     Argument& _CommandLine::find(Group *group, const char* what) \{}\par
{\bkmkstart AAAAAAADAN}{\bkmkend AAAAAAADAN}
00529 {\cf20         char* ptr = (char *) what;}\par
{\bkmkstart AAAAAAADAO}{\bkmkend AAAAAAADAO}
00530 {\cf20         if (sensitive) ptr = makeUpper(what);}\par
{\bkmkstart AAAAAAADAP}{\bkmkend AAAAAAADAP}
00531 {\cf20         Argument* arg = group->find(ptr);}\par
{\bkmkstart AAAAAAADAQ}{\bkmkend AAAAAAADAQ}
00532 {\cf20         if (arg == nullptr) throw CmdLineNotFoundException(ERR_NOT_FND, what);}\par
{\bkmkstart AAAAAAADAR}{\bkmkend AAAAAAADAR}
00533 {\cf20         return *arg;}\par
{\bkmkstart AAAAAAADAS}{\bkmkend AAAAAAADAS}
00534 {\cf20     \}}\par
{\bkmkstart AAAAAAADAT}{\bkmkend AAAAAAADAT}
00535 {\cf20     Argument* _CommandLine::findPointer(Group *group, const char* what) \{}\par
{\bkmkstart AAAAAAADAU}{\bkmkend AAAAAAADAU}
00536 {\cf20         char* ptr = (char *) what;}\par
{\bkmkstart AAAAAAADAV}{\bkmkend AAAAAAADAV}
00537 {\cf20         if (sensitive) ptr = makeUpper(what);}\par
{\bkmkstart AAAAAAADAW}{\bkmkend AAAAAAADAW}
00538 {\cf20         return group->find(ptr);}\par
{\bkmkstart AAAAAAADAX}{\bkmkend AAAAAAADAX}
00539 {\cf20     \}}\par
{\bkmkstart AAAAAAADAY}{\bkmkend AAAAAAADAY}
00540 {\cf20     template <typename T>}\par
{\bkmkstart AAAAAAADAZ}{\bkmkend AAAAAAADAZ}
00541 {\cf20     void _CommandLine::checkType(T, Type type) \{}\par
{\bkmkstart AAAAAAADBA}{\bkmkend AAAAAAADBA}
00542 {\cf20         string expected("");}\par
{\bkmkstart AAAAAAADBB}{\bkmkend AAAAAAADBB}
00543 {\cf20         switch (type) \{}\par
{\bkmkstart AAAAAAADBC}{\bkmkend AAAAAAADBC}
00544 {\cf20         case Type::NUMBER:  if (!is_same<T, int> && !is_same<T, long>) expected = "number";break;}\par
{\bkmkstart AAAAAAADBD}{\bkmkend AAAAAAADBD}
00545 {\cf20         case Type::DECIMAL: if (!is_same<T, float> && !is_same<T, double>) expected = "decimal"; break;}\par
{\bkmkstart AAAAAAADBE}{\bkmkend AAAAAAADBE}
00546 {\cf20         case Type::DATE:   if (!is_same<T, struct tm>) expected = "date";break;}\par
{\bkmkstart AAAAAAADBF}{\bkmkend AAAAAAADBF}
00547 {\cf20         case Type::TIME:   if (!is_same<T, struct tm>) expected = "time";break;}\par
{\bkmkstart AAAAAAADBG}{\bkmkend AAAAAAADBG}
00548 {\cf20         case Type::DATETIME: if (!is_same<T, struct tm>) expected = "datetiem"; break;}\par
{\bkmkstart AAAAAAADBH}{\bkmkend AAAAAAADBH}
00549 {\cf20         case Type::TMS:      if (!is_same<T, chrono::time_point>) expected = "timestamp";break;}\par
{\bkmkstart AAAAAAADBI}{\bkmkend AAAAAAADBI}
00550 {\cf20         case Type::DIR:}\par
{\bkmkstart AAAAAAADBJ}{\bkmkend AAAAAAADBJ}
00551 {\cf20         case Type::DIR_EXISTS: if (!is_same<T, filesystem::path>) expected = "directory";break;}\par
{\bkmkstart AAAAAAADBK}{\bkmkend AAAAAAADBK}
00552 {\cf20         case Type::FILE:}\par
{\bkmkstart AAAAAAADBL}{\bkmkend AAAAAAADBL}
00553 {\cf20         case Type::FILE_EXISTS: if (!is_same<T, filesystem::path>) expected = "file";break;}\par
{\bkmkstart AAAAAAADBM}{\bkmkend AAAAAAADBM}
00554 {\cf20         default: expected = "";}\par
{\bkmkstart AAAAAAADBN}{\bkmkend AAAAAAADBN}
00555 {\cf20         \}}\par
{\bkmkstart AAAAAAADBO}{\bkmkend AAAAAAADBO}
00556 {\cf20         if (expected.length() > 0) throw CmdLineInvalidTypeException(ERR_INV_TYPE, expected);}\par
{\bkmkstart AAAAAAADBP}{\bkmkend AAAAAAADBP}
00557 {\cf20     \}}\par
{\bkmkstart AAAAAAADBQ}{\bkmkend AAAAAAADBQ}
00558 {\cf20     template <typename T>}\par
{\bkmkstart AAAAAAADBR}{\bkmkend AAAAAAADBR}
00559 {\cf20     T _CommandLine::castValue(auto value) \{}\par
{\bkmkstart AAAAAAADBS}{\bkmkend AAAAAAADBS}
00560 {\cf20         size_t pos;}\par
{\bkmkstart AAAAAAADBT}{\bkmkend AAAAAAADBT}
00561 {\cf20         string::size_type sz;}\par
{\bkmkstart AAAAAAADBU}{\bkmkend AAAAAAADBU}
00562 {\cf20         if (is_same<T, int>::value) }\par
{\bkmkstart AAAAAAADBV}{\bkmkend AAAAAAADBV}
00563 {\cf20             return any_cast<int>(value);}\par
{\bkmkstart AAAAAAADBW}{\bkmkend AAAAAAADBW}
00564 {\cf20         if (is_same<T, long>::value) return validateNumber(value); }\par
{\bkmkstart AAAAAAADBX}{\bkmkend AAAAAAADBX}
00565 {\cf20 //          long l = stol(string(value), &pos, 0);}\par
{\bkmkstart AAAAAAADBY}{\bkmkend AAAAAAADBY}
00566 {\cf20 //          return any_cast<long>(value);}\par
{\bkmkstart AAAAAAADBZ}{\bkmkend AAAAAAADBZ}
00567 {\cf20 //      \}}\par
{\bkmkstart AAAAAAADCA}{\bkmkend AAAAAAADCA}
00568 {\cf20         if (is_same<T, float>::value) return any_cast<float>(value);}\par
{\bkmkstart AAAAAAADCB}{\bkmkend AAAAAAADCB}
00569 {\cf20         if (is_same<T, double>::value) return any_cast<double>(value);}\par
{\bkmkstart AAAAAAADCC}{\bkmkend AAAAAAADCC}
00570 {\cf20 //      if (!is_same<T, struct tm>::value) return any_cast<struct tm>(value);}\par
{\bkmkstart AAAAAAADCD}{\bkmkend AAAAAAADCD}
00571 {\cf20 //      if (!is_same<T, filesystem::path>::value) return std::any_cast<filesystem::path>(value);}\par
{\bkmkstart AAAAAAADCE}{\bkmkend AAAAAAADCE}
00572 {\cf20 //      return std::any_cast<string>(value);}\par
{\bkmkstart AAAAAAADCF}{\bkmkend AAAAAAADCF}
00573 {\cf20         return NULL;}\par
{\bkmkstart AAAAAAADCG}{\bkmkend AAAAAAADCG}
00574 {\cf20     \}}\par
{\bkmkstart AAAAAAADCH}{\bkmkend AAAAAAADCH}
00575 {\cf20     Options _CommandLine::getOptionsValue(bool def) \{}\par
{\bkmkstart AAAAAAADCI}{\bkmkend AAAAAAADCI}
00576 {\cf20         Options act;}\par
{\bkmkstart AAAAAAADCJ}{\bkmkend AAAAAAADCJ}
00577 {\cf20         for (auto it : options) \{}\par
{\bkmkstart AAAAAAADCK}{\bkmkend AAAAAAADCK}
00578 {\cf20             if (it.second.source != Source::AUTO) act.emplace(it.second.name, (def ? it.second.defValue : it.second.getValue()));}\par
{\bkmkstart AAAAAAADCL}{\bkmkend AAAAAAADCL}
00579 {\cf20         \}}\par
{\bkmkstart AAAAAAADCM}{\bkmkend AAAAAAADCM}
00580 {\cf20         return act;}\par
{\bkmkstart AAAAAAADCN}{\bkmkend AAAAAAADCN}
00581 {\cf20     \}}\par
{\bkmkstart AAAAAAADCO}{\bkmkend AAAAAAADCO}
00582 {\cf20     const char* _CommandLine::getValue(Group *grp, const char* name) \{}\par
{\bkmkstart AAAAAAADCP}{\bkmkend AAAAAAADCP}
00583 {\cf20         Argument& opt = find(grp, name);}\par
{\bkmkstart AAAAAAADCQ}{\bkmkend AAAAAAADCQ}
00584 {\cf20         return opt.getValue();}\par
{\bkmkstart AAAAAAADCR}{\bkmkend AAAAAAADCR}
00585 {\cf20     \}}\par
{\bkmkstart AAAAAAADCS}{\bkmkend AAAAAAADCS}
00586 {\cf20 \}}\par
{\bkmkstart AAAAAAADCT}{\bkmkend AAAAAAADCT}
00587 {\cf20 */}\par
}
}